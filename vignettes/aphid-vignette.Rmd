---
title: "The 'aphid' package for analysis with profile hidden Markov models"
author: "Shaun Wilkinson"
date: "2017-06-12"
output: rmarkdown::html_vignette
bibliography: aphid.bib
vignette: >
  %\VignetteIndexEntry{Introduction to the phylogram package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
#knitr::opts_chunk$set(out.width='750px', dpi=200)
knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

--------------------------------------------------------------------------------
## Abstract
**aphid** is an R package for the development and application of
hidden Markov models and profile HMMs for biological sequence analysis. 
It contains functions for multiple and pairwise sequence alignment, 
model construction and parameter optimization, calculation of conditional 
probabilities (implementation of the forward, backward and Viterbi algorithms),
tree-based sequence weighting, sequence simulation, and text file import/export. 
This package has a variety of uses including database searching, gene-finding 
and annotation, phylogenetic analysis and sequence classification.  

## Introduction
Hidden Markov models (HMMs) underlie many of the most important tasks in 
computational biology, including multiple sequence alignment, 
genome annotation, and increasingly, sequence database searching. 
Having originally been developed for speech recognition algorithms, 
their application to the field of molecular biology has increased 
dramatically as advances computational capacity enable full 
probabilistic analysis, where historically only heuristic algorithms 
were feasible. Pioneering this transition are two groups lead by 
Anders Krogh [@Krogh1994] and Sean Eddy [@Eddy1998], 
whose respective software packages 
SAM <https://compbio.soe.ucsc.edu/sam.html> 
and HMMER <http://www.hmmer.org> 
have underpinned HMM-based bioinformatic analysis for over 20 years. 

## The 'aphid' package
Here, we present an R package, **aphid** for analysis with 
profile hidden Markov models in the R
environment. 
The package contains functions for developing, plotting, importing and 
exporting both standard and profile HMMs, as well as implementations of 
the forward, backward and Viterbi algorithms for computing full and optimal
conditional sequence probabilities. 


###Dependencies
Functions in the aphid package are compatible with "DNAbin" 
and "AAbin" objects generated by the ape package. 
These object types, in which sequences are represented in a 
bit-level coding scheme, are recommended for maximizing memory and speed effficiency.
The aphid package is designed to work in conjunction with the "DNAbin" and 
"AAbin" object types produced by the ape package [@Paradis2004; @Paradis2012]. 
This is an essential resource for those using R for biological sequence analysis, 
since it provides a binary coding format for nucleotides and amino acids that 
maximizes memory and speed efficiency. 
While aphid also works with standard character sequences, 
it will not recognize the DNA and amino acid amibguity codes and therefore 
is not guaranteed to treat them appropriately.

###Performant code
The forward, backward and Viterbi algorithms are $O(n^2)$ in time and memory for
profile HMMs, and $O(nm)$ for standard HMMs (where *n* is the sequence length
and *m* is the number of hidden states). 
To maximize speed, the low-level dynamic programming functions 
(including the maximum *a posteriori* algorithm for assignment of match 
and insert states) are written in C++ with the help of the Rcpp package. 
Note that R versions of these functions are also maintained for the purposes 
of debugging, experimentation and code interpretation.

###Classes
The aphid package creates two primary object classes, "HMM" 
(hidden Markov models) and "PHMM" (profile hidden Markov models) 
with the functions deriveHMM and derivePHMM, respectively. 
These objects are lists consisting of emission and transition 
probability matrices (elements named *E* and *A*), 
vectors of non-position-specific background emission and transition 
probabilies (denoted *qe* and *qa*) and other model metadata including
*name*, *description*, *size* (the neumber of modules in the model), and  
*alphabet* (the alphabet of symbols/residues emitted by the model). 
Objects of class "Viterbi" and "fullprob" are also generated by 
the Viterbi and forward/backward functions, respectively. 

###Functions
In the following sections, HMMs and PHMMs are revisited and with illustrations 
and examples from the package.

#### Hidden Markov Models
A hidden Markov model is a hypothetical data-generating mechanism for a 
sequence or set of sequences. 
It is depicted by a network of *states* each 
emitting symbols from a finite *alphabet* according to a set 
of *emission* probabilities $e$ specific to each state. 
The states are traversed by an interconnecting 
set of *transition* probabilities $a$, including the probability
of remaining in a given state and those of transitioning 
to each of the other states. 
A simple example called the "dishonest casino" is given in [@Durbin1998]. 
An imaginary casino has two die, one fair and one weighted.
The fair dice emits residues from the alphabet {1, 2, 3, 4, 5, 6}
with equal probabilities ($1/6$ for each residue).
For the 'loaded' dice, the probability of rolling a "6" is $1/2$, while
that of each of the other five residues is $1/10$.
The dealer secretly switches from the fair to the loaded dice with a 
probability of 0.05 for each roll (retaining the fair dice with a 95% probability), 
and back again with a probability of 0.1.


```{r, fig.width=8, fig.height=4}
## Dishonest casino example from Durbin et al (1998) chapter 3.2
library("aphid")
states = c("Begin", "Fair", "Loaded")
residues = paste(1:6)
### Define transition probability matrix A
A <- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
dimnames(A) <- list(from = states, to = states)
### Define emission probability matrix E
E <- matrix(c((1/6), (1/6), (1/6), (1/6), (1/6), (1/6),
              (1/10), (1/10), (1/10), (1/10), (1/10), (1/2)),
            nrow = 2, byrow = TRUE) 
dimnames(E) <- list(states = states[-1], residues = residues)
### Create HMM
x <- structure(list(A = A, E = E), class = "HMM")
### Plot the model with labaled transition probabilities
plot(x, main = "Dishonest casino hidden Markov model", textexp = 1.5)
text(x = 0.01, y = 0.5, labels = "0.95")
text(x = 0.51, y = 0.5, labels = "0.90")
text(x = 0.5, y = 0.8, labels = "0.05")
text(x = 0.5, y = 0.2, labels = "0.10")

```

#### Figure 1: A simple hidden Markov model for the dishonest casino example.
Transition probabilities are depicted as weighted lines, and emission probabilities
as horizontal bars. No begin/end state is modeled in this example; however, this 
can be achieved by entering the probabilities in the first row and column of the 
transition matrix and passing `begin = TRUE` to `plot.HMM`.

For any given sequence of observed rolls we can establish the most 
*likely* sequence of hidden states (i.e. when the dice-switches most likely occurred) 
using the Viterbi algorithm. In the example from Durbin et al [-@Durbin1998], 
the observed sequence of 300 rolls is
```{r, echo = FALSE}
data(casino)
cat("", 
    paste0(casino[1:50], collapse = ""), "\n", 
    paste0(casino[51:100], collapse = ""), "\n", 
    paste0(casino[101:150], collapse = ""), "\n", 
    paste0(casino[151:200], collapse = ""), "\n", 
    paste0(casino[201:250], collapse = ""), "\n", 
    paste0(casino[251:300], collapse = ""), "\n")
```

Some clusters of 6's suggest that the loaded dice made an appearance 
at some stage, but when did the dice-switching occur?
To find the most likely sequence of hiden states given the model we can run:
```{r}
data(casino)
vit1 <- Viterbi(x, casino)
## 'path' element of returned object is a vector of indices 
predicted <- c("F", "L")[vit1$path + 1]
cat("", 
    paste0(predicted[1:50], collapse = ""), "\n", 
    paste0(predicted[51:100], collapse = ""), "\n", 
    paste0(predicted[101:150], collapse = ""), "\n", 
    paste0(predicted[151:200], collapse = ""), "\n", 
    paste0(predicted[201:250], collapse = ""), "\n", 
    paste0(predicted[251:300], collapse = ""), "\n")
```

Comparing that with the actual hidden sequence, the prediction wasn't 
too far off:
```{r, echo = FALSE}
actual <- c("F", "L")[match(names(casino), c("Fair", "Loaded"))]

cat("", 
    "Actual    ", paste0(actual[1:50], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[1:50], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[51:100], collapse = ""), "\n",
    "Predicted ", paste0(predicted[51:100], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[101:150], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[101:150], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[151:200], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[151:200], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[201:250], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[201:250], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[251:300], collapse = ""), "\n",
    "Predicted ", paste0(predicted[251:300], collapse = ""), "\n")
```


We can also calculate the full probability of the sequence given the model, 
using the `forward` or `backward` algorithm. 
This is useful not just for beating the house, but also for a huge variety of 
other applications!

The **aphid** package also has HMM building functions `deriveHMM` and `derivePHMM`
To derive an HMM from our sequence with its known a state path (included as a 
'names' attribute), we can run:   

```{r, fig.width=8, fig.height=4}
y <- deriveHMM(list(casino), logspace = FALSE)
plot(y, main = "Derived HMM for dishonest casino", textexp = 1.5)
text(x = 0.01, y = 0.5, labels = round(y$A["Fair", "Fair"], 2))
text(x = 0.51, y = 0.5, labels = round(y$A["Loaded", "Loaded"], 2))
text(x = 0.5, y = 0.8, labels = round(y$A["Fair", "Loaded"], 2))
text(x = 0.5, y = 0.2, labels = round(y$A["Loaded", "Fair"], 2))
```

#### Figure 2: A simple HMM derived from the single sequence of 300 dice rolls.
This is fairly close to the actual model, despite the fact that the training data 
consists of just a single sequence.
One would typically derive an HMM from a list of many such sequences (hence why 
the input argument is a list and not a vector) but this example is simplified
for clarity. 


#### Profile Hidden Markov Models 
A profile hidden Markov model is similar to a standard HMM except that emission
and transition probabilities are *position specific*. 
That is, they can change at each point along the sequence. 
These models typically have many more parameters than their simpler 
HMM counterparts, but for biological sequence analysis this property 
can be an extremely powerful property. 
Consider this small partial alignment of globin amino acid sequences, also from 
[@Durbin1998]:

```{r}
data(globins)
globins
```



..file import/export compatible with the HMMER (v3) software package [@Finn2011a]. 



## Further Reading
This package was written based on the algorithms described in 
Durbin et al. [-@Durbin1998].
This book offers an in depth explanation of hidden Markov models 
and profile HMMs for users of all levels of familiarity. 
Many of the examples and datasets in the package are directly 
derived from the text, which serves as a useful primer for this 
package.
There are also excellent rescources available for those wishing to use 
profile HMMs outside of the R environment. 
The aphid package maintains compatibility with the HMMER software suite 
through the file input and output functions readPHMM and writePHMM. 
Those interested are further encouraged to check out the SAM software 
package, which also features a comprehensive suite of functions and 
tutorials.

## Acknowledgements
This software was developed at Victoria University of Wellington, NZ, 
with funding from a Rutherford Foundation Postdoctoral Research Fellowship 
award from the Royal Society of New Zealand.

## References
