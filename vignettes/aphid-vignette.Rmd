---
title: "The 'aphid' package for analysis with profile hidden Markov models"
author: "Shaun Wilkinson"
date: "2017-06-12"
output: rmarkdown::html_vignette
bibliography: aphid.bib
vignette: >
  %\VignetteIndexEntry{Introduction to the phylogram package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, echo = FALSE, message = FALSE, warning = FALSE}
#knitr::opts_chunk$set(out.width='750px', dpi=200)
#knitr::opts_chunk$set(collapse = TRUE, comment = "#>")
```

--------------------------------------------------------------------------------
## Abstract
**aphid** is an R package for the development and application of
hidden Markov models and profile HMMs for biological sequence analysis. 
It contains functions for multiple and pairwise sequence alignment, 
model construction and parameter optimization, implementation of the forward, 
backward and Viterbi algorithms for conditional sequence probabilities, 
tree-based sequence weighting, simulation, and text file import/export. 
The package has a wide variety of uses including database searching, 
gene-finding and annotation, phylogenetic analysis and sequence classification.  

## Introduction
Hidden Markov models (HMMs) underlie many of the most important tasks in 
computational biology, including multiple sequence alignment, 
genome annotation, and increasingly, sequence database searching. 
Originally developed for speech recognition algorithms, 
their application to the field of molecular biology has increased 
dramatically as advances computational capacity enable full 
probabilistic analysis, where historically only heuristic algorithms 
were feasible. 
Pioneering this transition are two groups lead by 
Anders Krogh and Sean Eddy, 
whose respective software packages 
[SAM](https://compbio.soe.ucsc.edu/sam.html) 
and [HMMER](http://www.hmmer.org) 
have underpinned HMM-based bioinformatic analysis for over two 
decades.  

Here, we present the **aphid** package for analysis with 
profile hidden Markov models in the R environment [@RCoreTeam2015]. 
The package contains functions for developing, plotting, importing and 
exporting both standard and profile HMMs, as well as implementations of 
the forward, backward and Viterbi algorithms for computing full and optimal
conditional sequence probabilities. The package also features
a multiple sequence alignment tool that produces high quality alignments
*via* profile HMM training.

## The 'aphid' package
###Dependencies
The **aphid** package is designed to work in conjunction with the "DNAbin" 
and "AAbin" object types produced using the **ape** package 
[@Paradis2004; @Paradis2012].
These object types, in which sequences are represented in a bit-level coding 
scheme, are preferred over standard character-type sequences for maximizing 
memory and speed efficiency.
While we highly recommend using **ape** alongside **aphid**, it is not a 
requisite and as such is listed in the "Suggests" rather than "Imports" 
section of the package description file. 
Indeed, any sequence of standard ASCII characters is supported, 
making **aphid** suitable for other applications outside of biological 
sequence analysis. 
However, it should be noted that if DNA and/or amino acid sequences are 
inout as character vectors, the **aphid** functions may not recognize 
the ambiguity codes and therefore are not guaranteed to treat them 
appropriately.

To maximize speed, the low-level dynamic programming functions
(including the forward, backward, Viterbi, and maximum 
*a posteriori* algorithms) are written in C++ linking to the Rcpp package 
[@Eddelbuettel2011]. 
R versions of these functions are also maintained for the purposes 
of debugging, experimentation and code interpretation.
This package also relies on the **openssl** package [@Ooms2016] for 
sequence and alignment comparisons using the MD5 hash algorithm.

###Classes
Two primary object classes, "HMM" (hidden Markov model) and 
"PHMM" (profile hidden Markov model) are generated using the **aphid** 
functions deriveHMM and derivePHMM, respectively. 
These objects are lists consisting of emission and transition 
probability matrices (elements named "E" and "A"), 
vectors of non-position-specific background emission and transition 
probabilities ("qe" and "qa", respectively) and other model metadata including
"name", "description", "size" (the number of modules in the model), and 
"alphabet" (the set of symbols/residues emitted by the model). 
Objects of class "Viterbi" and "fullprob" are also generated by 
the Viterbi and forward/backward functions, respectively These are 
predominantly created for the purposes of succinct console-printing. 

###Functions
HMMs and PHMMs are explained in more detail throughout the following sections 
using **aphid** package functions to demonstrate their utility. 
The examples are borrowed from Durbin et al [-@Durbin1998], 
to which users are encouraged to refer for a more in-depth explanation on the 
theory and application of these models.  
Book chapter numbers are provided for ease of reference. 

#### Hidden Markov Models
A hidden Markov model is a hypothetical data-generating mechanism for a 
sequence or set of sequences. 
It is depicted by a network of *states* each 
emitting symbols from a finite *alphabet* according to a set 
of *emission probabilities* whose values are specific to each state. 
The states are traversed by an interconnecting 
set of *transition probabilities*, that include the probability
of remaining in a given state and those of transitioning 
to each of the other connected states. 
A simple example of a "dishonest casino" is given in Dubrin et al 
[-@Durbin1998] chapter 3.2. 
An imaginary casino has two die, one fair and one weighted.
The fair dice emits residues from the alphabet {1, 2, 3, 4, 5, 6}
with equal probabilities (1/6 for each residue).
The probability of rolling a "6" with the loaded dice is 0.5, while
that of each of the other five residues is 0.1.
If the dealer has the fair dice, he may secretly switch to the loaded 
dice with a probability of 0.05 after each roll, leaving a 
95% chance that he will retain the fair dice. Alternatively, if he has the 
loaded dice, he will switch back to the fair dice with a probability of 
0.1, or more likely, retain the loaded dice with a probability of 0.9.

This example can be represented by a standard two-state hidden Markov
model. The following code manually builds and plots the "HMM" object. 

```{r, fig.width=8, fig.height=4}
library("aphid")
states = c("Begin", "Fair", "Loaded")
residues = paste(1:6)
### Define transition probability matrix A
A <- matrix(c(0, 0, 0, 0.99, 0.95, 0.1, 0.01, 0.05, 0.9), nrow = 3)
dimnames(A) <- list(from = states, to = states)
### Define emission probability matrix E
E <- matrix(c(rep(1/6, 6), rep(1/10, 5), 1/2), nrow = 2, byrow = TRUE)
dimnames(E) <- list(states = states[-1], residues = residues)
### Create the HMM object
x <- structure(list(A = A, E = E), class = "HMM")
### Plot the model with labaled transition probabilities
plot(x, main = "Dishonest casino hidden Markov model", textexp = 1.5)
text(x = 0.08, y = 0.5, labels = "0.95")
text(x = 0.51, y = 0.5, labels = "0.90")
text(x = 0.5, y = 0.9, labels = "0.05")
text(x = 0.5, y = 0.1, labels = "0.10")
```
**Figure 1: A simple hidden Markov model for the dishonest casino example.**
The plot.HMM method depicts the transition probabilities as weighted lines, 
and emission probabilities as horizontal grey bars. 
No begin/end state is modeled in this example; however, this can be achieved 
by entering non-zero probabilities in the first row and column of the 
transition matrix and passing "begin = TRUE" to `plot.HMM`.


For any given sequence of observed rolls, we can establish the most 
*likely* sequence of hidden states (i.e. when the dice-switching most 
likely occurred) using the Viterbi algorithm. 
In the example given in Durbin et al [-@Durbin1998], the observed sequence 
of 300 rolls is
```{r, echo = FALSE}
data(casino)
cat("", 
    paste0(casino[1:50], collapse = ""), "\n", 
    paste0(casino[51:100], collapse = ""), "\n", 
    paste0(casino[101:150], collapse = ""), "\n", 
    paste0(casino[151:200], collapse = ""), "\n", 
    paste0(casino[201:250], collapse = ""), "\n", 
    paste0(casino[251:300], collapse = ""), "\n")
```

Some clusters of 6's suggest that the loaded dice made an appearance 
at some stage, but when did the dice-switching occur?
The Viterbi algorithm is used to find the most likely sequence of hidden 
states given the model:
```{r}
data(casino)
actual <- c("F", "L")[match(names(casino), c("Fair", "Loaded"))]
### actual path is stored in the names attribute of the sequence
vit1 <- Viterbi(x, casino)
predicted <- c("F", "L")[vit1$path + 1]
### note the path element of the output Viterbi object is an integer vector
### the addition of 1 to the path converts from C/C++ to R's indexing style
```

Comparing the predicted path with the actual hidden sequence, the Viterbi 
algorithm wasn't far off:
```{r, echo = FALSE}

cat("", 
    "Actual    ", paste0(actual[1:50], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[1:50], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[51:100], collapse = ""), "\n",
    "Predicted ", paste0(predicted[51:100], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[101:150], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[101:150], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[151:200], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[151:200], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[201:250], collapse = ""), "\n", 
    "Predicted ", paste0(predicted[201:250], collapse = ""), "\n\n", 
    "Actual    ", paste0(actual[251:300], collapse = ""), "\n",
    "Predicted ", paste0(predicted[251:300], collapse = ""), "\n")
```


We can also calculate the full probability of the sequence given the model, 
using the `forward` or `backward` algorithm. 
This is useful not just for beating the house, but for a variety of 
other applications!

##### Deriving HMMs from sequence data
The **aphid** package also has HMM building functions `deriveHMM` and `derivePHMM`
To derive an HMM from our sequence with its known a state path (included as a 
'names' attribute), we can run:   

```{r, fig.width=8, fig.height=4}
y <- deriveHMM(list(casino), logspace = FALSE)
plot(y, main = "Derived HMM for dishonest casino", textexp = 1.5)
text(x = 0.08, y = 0.5, labels = round(y$A["Fair", "Fair"], 2))
text(x = 0.51, y = 0.5, labels = round(y$A["Loaded", "Loaded"], 2))
text(x = 0.5, y = 0.9, labels = round(y$A["Fair", "Loaded"], 2))
text(x = 0.5, y = 0.1, labels = round(y$A["Loaded", "Fair"], 2))
```

**Figure 2: A simple HMM derived from the single sequence of 300 dice rolls.**
This is fairly close to the actual model, despite the fact that the training data 
consists of just a single sequence.
One would typically derive an HMM from a list of many such sequences (hence why 
the input argument is a list and not a vector) but this example is simplified
for clarity. 


#### Profile Hidden Markov Models 
A profile hidden Markov model is an extension of a standard HMM where emission
and transition probabilities are *position specific*. 
That is, they can change at each point along the sequence. 
These models typically have many more parameters than their simpler 
HMM counterparts, but can be very powerful for sequence analysis. 
The precursor to a profile HMM is normally a multiple sequence alignment.
Each column in the alignment will generally (but not always) be nominated one 
internal position or "module" in the model, with each module consisting of 
three states: 

* a silent *delete* state that does not emit residues. 
* an *insert* state with emission probabilities according to the background
residues in the entire alignment.
* a *match* state with emission probabilities according to the frequency of 
residues in the alignment column. 


Figure 3 shows the three state types as rectangles, diamonds and squares, respectively.
The states are linked by transition probabilities shown by directed arrows in the graph. 

Consider this small partial alignment of globin amino acid sequences from Durbin
et al [-@Durbin1998] chapter 5.3:

```{r}
data(globins)
globins
```

Position-specific patterns include a high probability of observing a "V"
at position 1 and an "A" or "G" at position 3. 
When tabulating the frequencies it is also prudent to add pseudo-counts, 
since the absence of a particular transition or emission type does not 
preclude the possibility of it occurring in another (unobserved) sequence. 
Pseudo-counts can be Laplacean (add one of each emission and transition type), 
background (adjusts the Laplacean pseudo-counts to reflect the background frequencies 
derived from the entire alignment), or user defined, which can include 
more complex pseudo-count schemes such as Dirichlet mixtures [@Durbin1998].  
The default option for the derivePHMM function is `pseudocounts = "background"`.

We can derive a profile HMM from the globin data and plot the graph as follows:

```{r, fig.width=8, fig.height=4}
globins.PHMM <- derivePHMM(globins, residues = "AMINO", seqweights = NULL)
plot(globins.PHMM, main = "Profile HMM for small globin alignment")
```

**Figure 3: Profile HMM derived from a partial globin sequence alignment.**
Match states are shown as rectangles, insert states as diamonds, and delete 
states as circles. The grey horizontal bars represent the emission 
probabilities of each residue in the alphabet (in this case the amino acid 
alphabet) at each position in the model. Numbers in the delete states show 
the position in the model, while those in the insert states are the 
probabilities of remaining in the current insert state at the next emission 
cycle. Lines are weighted and directed where necessary to reflect the 
transition probabilities between states.
The large "B" and "E" labels represent are the silent begin and end states, 
respectively.

Note that there are only 8 internal modules (excluding the begin and end states), 
while the alignment had 10 columns. 
The `derivePHMM` function decided (using the maximum *a posteriori* algorithm)
that there was not enough residue information in columns 4 and 5 of the alignment 
to warrant assigning them internal modules in the model.
Instead, the last sequence in the alignment (GLB1_GLYDI) was considered to have 
entered the insert state at position 3 where it remained for two emission cycles
(emitting an "A" and a "D") before transitioning to the match state in module 4.
We can show this by calculating the optimal path of that sequence through the 
model using the Viterbi algorithm:

```{r}
path <- Viterbi(globins.PHMM, globins["GLB1_GLYDI", ])$path
path
```
The "path" element of the Viterbi object is an integer vector with elements taking 
values 0 ("delete"), 1 ("match") or 2 ("insert"). 
The path can be returned as characters instead of indices by running:

```{r}
c("DELETE", "MATCH", "INSERT")[path + 1]
## adding 1 converts from the C++ indexing style to R's style
```

Sequences do not have to be aligned to produce a profile HMM.
The function `derivePHMM` can optionally take a list of unaligned
sequences, in which case the longest sequence is used as a 'seed'
to create a preliminary profile HMM, and the model is iteratively
trained using the sequence list via either the Baum Welch or Viterbi 
training algorithm (see model training section below). 

##### File I/O
Profile HMMs can be exported as text files in the HMMER v3 format
(<http://www.hmmer.org/>) using the function `writePHMM` for example,
the small globin profile HMM can be exported by running 
`writePHMM(globins.PHMM)`. 
Similarly, a HMMER v3 text file can be parsed into R as an object of 
class "PHMM" with the function `readPHMM`. 

##### Sequence Simulation
To simulate data with random variation, the **aphid** package features the 
function `generate` with methods for both HMMs and PHMMs. Sequences are 
generated recursively using the transition and emission probabilities
from within the model. There are two compulsory arguments, a model 
(object class: "HMM" or PHMM) and the argument `size`, which specifies
the maximum length of the sequence to prevent overflow 
(e.g. if insert-insert transition probabilities are relatively high). 
For example, to simulate a list of 10 random sequences from the small globin
profile HMM, run:

```{r}
sim <- list()
set.seed(9999)
for(i in 1:10) sim[[i]] <- generate(globins.PHMM, size = 20)
sim
```
Note that the names attributes specify which state each residue was emitted 
from, and gaps are emitted from delete states. 
If not required, the gaps can be removed as follows:
```{r}
sim <- lapply(sim, function(s) s[s != "-"])
```

##### Model Training
The **aphid** package offers the function `train` for updating model
parameters using either the Baum Welch or Viterbi training algorithm.
Both are iterative refinement algorithms; the former
algorithm does not rely on a multiple sequence alignment
but is generally much slower than the latter. 
The Viterbi training operation can be sped up further on larger 
workstations by specifying the "cores" argument for parallel processing. 
The best choice of training algorithm will generally depend on the 
nature of the problem and the computing resources available. 
For more information see Durbin et al [-@Durbin1998] chapter 3.3 for 
standard HMMs and chapter 6.5 for profile HMMs.
To train our small globins profile HMM  with the sequences 
simulated in the previous step using the Baum Welch algorithm, run:
```{r}
globins2.PHMM <- train(globins.PHMM, sim, method = "BaumWelch", deltaLL = 0.001)
```

As shown in the feedback (which can be switched off by setting "quiet = TRUE"),
this operation took 7 expectation-maximization iterations to converge to the 
specified delta log-likelihood threshold of 0.001.

## Sequence Alignment
The **aphid** package can be used to produce high-quality multiple sequence 
alignments by iterative model training. 
The function `align` takes as its primary argument a list of sequences 
either as a "DNAbin" object, an "AAbin" object, or a list of character sequences. 
An object of class "PHMM" can be passed as the optional secondary 
argument ("model"), in which case the sequences are aligned to the model to 
produce the alignment matrix. 
If "model = NULL" (default), a preliminary model is derived using the 
'seed' sequence method outlined above, the model is trained using either 
the Baum Welch or Viterbi training algorithm (specified *via* the "method" 
argument) and the sequences aligned to the model to produce the alignment.
Note that the `align` function will perform a pairwise alignment using the
Viterbi algorithm without a profile HMM if only two sequences are present in 
the input list.
In this final example, we will align the simulated sequences using the 
PHMM we derived from the original alignment.

```{r}
align(sim, model = globins.PHMM, seqweights = NULL, residues = "AMINO")
```
Note that the column names show the progressive positions in the model
and where residues were emitted by insert states (e.g. sequence 1
position 3, etc).   

## Further Reading
This package was written based on the algorithms described in 
Durbin et al. [-@Durbin1998].
This book offers an in depth explanation of hidden Markov models 
and profile HMMs for users of all levels of familiarity. 
Many of the examples and datasets in the package are directly 
derived from the text, which serves as a useful primer for this 
package.
There are also excellent resources available for those wishing to use 
profile HMMs outside of the R environment. 
The aphid package maintains compatibility with the HMMER software suite 
through the file input and output functions readPHMM and writePHMM. 
Those interested are further encouraged to check out the SAM software 
package, which also features a comprehensive suite of functions and 
tutorials.

## Acknowledgements
This software was developed at Victoria University of Wellington, NZ, 
with funding from a Rutherford Foundation Postdoctoral Research Fellowship 
award from the Royal Society of New Zealand.

## References
