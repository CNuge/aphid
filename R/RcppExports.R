# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' DNA ambiguity probabilities.
#'
#' Find DNA ambiguity probabilities.
#'
#' @param x a pentadecimal integer (arity = 15).
#' @param probs a length-4 vector of logged probabilities.
DNAprobC2 <- function(x, probs) {
    .Call('profile_DNAprobC2', PACKAGE = 'profile', x, probs)
}

#' AA ambiguity probabilities.
#'
#' Find AA ambiguity probabilities.
#'
#' @param x a heptovigdecimal integer (arity = 27).
#' @param probs a length-20 vector of logged probab.
AAprobC2 <- function(x, probs) {
    .Call('profile_AAprobC2', PACKAGE = 'profile', x, probs)
}

#' Sum of logged probabilities.
#'
#' \code{"logsum"} takes a vector of logged probabilities and returns its sum.
#'
#' @param x a vector of logged probabilities.
logsum <- function(x) {
    .Call('profile_logsum', PACKAGE = 'profile', x)
}

#' Find the index of the maximum with ties broken at random.
#'
#' Returns the location of the maximum value in a numeric or integer vector.
#'
#' @param x a numeric or integer vector.
#'
whichmax <- function(x, start = 1L) {
    .Call('profile_whichmax', PACKAGE = 'profile', x, start)
}

#' Optimal path of sequence through model.
#'
#' \code{ViterbiC} finds the optimal path of a sequence through a HMM
#' or PHMM and returns its log-odds score.
#'
#' @param x an object of class \code{HMM} or \code{PHMM}, or a character vector.
#' @param y a character vector consisting of residues emitted by the
#' HMM or PHMM.
#' @param logspace logical argument indicating whether the emission
#' and transmission probabilities for the model(s) are logged.
#' @name ViterbiC
Viterbi_default <- function(x, y, type, d, e, S, windowspace, offset = 0) {
    .Call('profile_Viterbi_default', PACKAGE = 'profile', x, y, type, d, e, S, windowspace, offset)
}

Viterbi_HMM <- function(y, A, E, DNA = FALSE, AA = FALSE) {
    .Call('profile_Viterbi_HMM', PACKAGE = 'profile', y, A, E, DNA, AA)
}

Viterbi_PHMM <- function(y, A, E, qe, qey, type, windowspace, offset = 0, DI = FALSE, ID = FALSE, DNA = FALSE, AA = FALSE) {
    .Call('profile_Viterbi_PHMM', PACKAGE = 'profile', y, A, E, qe, qey, type, windowspace, offset, DI, ID, DNA, AA)
}

Viterbi_PP <- function(Ax, Ay, Ex, Ey, qe, type, windowspace, offset = 0) {
    .Call('profile_Viterbi_PP', PACKAGE = 'profile', Ax, Ay, Ex, Ey, qe, type, windowspace, offset)
}

#' Full probability of a sequence given a model.
#'
#' Implementation of the forward algorithm to caluclate the full (log) probability
#' of a sequence through a given a HMM or profile HMM.
#' @param y an integer vector with same arity as number of columns of E
#'
forward_HMM <- function(y, A, E, DNA = FALSE, AA = FALSE) {
    .Call('profile_forward_HMM', PACKAGE = 'profile', y, A, E, DNA, AA)
}

forward_PHMM <- function(y, A, E, qe, qey, type, windowspace, DI = FALSE, ID = FALSE, DNA = FALSE, AA = FALSE) {
    .Call('profile_forward_PHMM', PACKAGE = 'profile', y, A, E, qe, qey, type, windowspace, DI, ID, DNA, AA)
}

backward_HMM <- function(y, A, E, DNA = FALSE, AA = FALSE) {
    .Call('profile_backward_HMM', PACKAGE = 'profile', y, A, E, DNA, AA)
}

backward_PHMM <- function(y, A, E, qe, qey, type, windowspace, DI = FALSE, ID = FALSE, DNA = FALSE, AA = FALSE) {
    .Call('profile_backward_PHMM', PACKAGE = 'profile', y, A, E, qe, qey, type, windowspace, DI, ID, DNA, AA)
}

kcount_DNA <- function(x, k = 5L) {
    .Call('profile_kcount_DNA', PACKAGE = 'profile', x, k)
}

mapC <- function(ecs, notgaps, pseudocounts, seqweights, qe, lambda = 0) {
    .Call('profile_mapC', PACKAGE = 'profile', ecs, notgaps, pseudocounts, seqweights, qe, lambda)
}

returnmod <- function(x) {
    .Call('profile_returnmod', PACKAGE = 'profile', x)
}

progression <- function(path, start) {
    .Call('profile_progression', PACKAGE = 'profile', path, start)
}

progression2 <- function(path, start) {
    .Call('profile_progression2', PACKAGE = 'profile', path, start)
}

#' Count transition frequencies.
#'
#' Summation of transition frequencies in an integer vector.
#'
#' @param x an integer vector.
#' @param arity an integer representing the numbering system of the input vector,
#' 2 for binary, 3 for ternary, etc.
#'
transitioncount <- function(x, arity) {
    .Call('profile_transitioncount', PACKAGE = 'profile', x, arity)
}

emissioncount <- function(states, statearity, residues, resarity) {
    .Call('profile_emissioncount', PACKAGE = 'profile', states, statearity, residues, resarity)
}

tab9C <- function(x, seqweights) {
    .Call('profile_tab9C', PACKAGE = 'profile', x, seqweights)
}

